# 数字编码规则

> 参考链接：https://segmentfault.com/a/1190000017090272

### 基本规则

js存储所有数字都是以双精度浮点数储存，也就是将数字转化为二进制，然后去除左侧的`0`，将其变为`1.010101···101 * 2^x[x为去除0的个数]`，这里的小数点后买呢的就是0-51共52位的分数位，x则是52-62共11为的指数位，最后是以为标志正负的数

* 0 - 51 位是 分数f（fraction ）
* 52 - 62 位是 指数（exponent ）
* 63 位 是 标志位 （sign）

### 分数

* 分数部分即是小数点后面的部分，他和前一位`1`组合再乘以指数部分，就是原先的数字的二进制数
* 所以要表示一个整数，就等于是分数和前一位1组合以后乘以指数部分进行移位以后，小数点之后的数字全是0

### 指数

* 指数一共11位，因为指数也有正副，所以，令1023[01111111111]为0，1024[10000000000]就是1，所以最大是2047[11111111111]就是1024，最小是0[00000000000]也就是-1023。
* 0代表`NaN`，2047代表`infinity`
* 还有一种非常接近0的数，转化的过程为非规范转化。`0.f * 2^−1022`f分数部分一定是大于0的，这个时候不会去除首位的0，因为默认一般首位为1。最大为`1.0 * 2^−1022`，最小为`0.1 * 2^−1022`

### 一些异常

#### 不精确（Inexact）[十进制分数]

* 一个操作返回不精确的结果 - 有太多有意义的数字需要分数f去存，那就返回一个四舍五入的结果
* 因为分数转二进制又是并不能完美转化[详情请查看十进制分数转二进制]，这样就会出小误差，这样误差通常会比较小，但是加法可以使这个偏差变得可见
* 所以处理分数尽量转化为整数处理最为稳妥

```
> 0.1 + 0.2
0.30000000000000004
```

#### 最大整数

* 因为分数部分最多为52位1，再加上第一位1一共是53位1，则看起来最大的数字应该是`Math.pow(2, 53) - 1`
* 实际上虽然分数位数填满了，但是指数部分并没有填满，所以指数部分可以继续添加，则这个数字是可以到指数部分被填满
* 但是，因为指数部分的增加代表着分数部分增加2的倍数，所以是没有办法+1的，所以`Math.pow(2, 53) - 1`之后的数是不安全的
* 综上，安全的整数是`-2^53 到 2^53 `之间

```
// 分数f的最大值（这也可以算是一个溢出操作），但根据 IEEE 754只有超过了指数的范围才算溢出。
> 9007199254740992 + 1
9007199254740992
```

#### 无效

进行一个无效操作。例如，给一个负数开平方，返回NaN

```
> Math.sqrt(-1)
NaN
```

####除以0

返回正或者负的infinity(无穷大)

```
> 3 / 0
Infinity
> -5 / 0
-Infinity
```

#### 溢出(overflow)，潜流（underflow)

* 结果太大，无法表示。这时是指数已经太大， (p ≥ 1024).根据标志位，正或者负溢出，返回正或者负的infinity（无穷大）。

* 结果太接近于0，这时是指数已经太小(p ≤ −1023). 返回一个非规范化的数字，或者0.

```
// 溢出
> Math.pow(2, 2048)
Infinity
> -Math.pow(2, 2048)
-Infinity
// 潜流
> Math.pow(2, -2048)
0 
```

