# JavaScript垃圾回收机制

> 参考链接：https://github.com/zqjflash/nodejs-memory

javascript中声明变量都会开辟出新的内存地址储存变量内容，随着程序的运行，运用到的变量会越来越多，这个时候就需要对一些“垃圾”变量进行清理，对他们所占用的内存进行回收。以此保证程序的流畅运行。

javascript的内存管理是自动的，会在特定时机运用**GC算法**进行垃圾回收

当一个内存地址，不再被引用，或者没有能访问到的指针时，就被视为“垃圾”。简单点来说，就是这个变量对程序运行是无用的，或者是没有办法用的，这个时候，它就是一个“垃圾”，需要被回收。

### GC算法

GC是一种机制，内部包含一个垃圾回收器，它会按照某种规则，完成按照垃圾，释放空间，回收空间的等工作。这种规则就是GC算法

#### 引用计数

核心思想：对每个变量设置引用数，判断当前引用数是否为0

* 建立引用计数器
* 引用关系发生改变时修改引用数
* 引用数字为0时，立即清理垃圾

##### 优点

* 发现垃圾立即回收，减少申请内存时的耗时，减少程序暂停

##### 缺点

* 无法回收循环对象
* 时间开销大，维护引用计数器需要耗时

#### 标记清除 Mark-Sweep

核心思想：将垃圾回收分为标记和清除两个阶段

* 遍历所有的对像寻找活动对象进行标记
* 遍历所有的对象清楚没有标记的对象
* 回收相应空间

##### 优点

* 可以回收循环对象
* 不需要维护额外的计数器

##### 缺点

* 清除了没有标记的对象，释放了对应的内存，但是释放的内存并不连续，无法很好的被再次利用，导致内存碎片化
* 不会立即回收对象

#### 标记整理 Mark-Compact

核心思想：与标记清除一致，多了整理内存的操作

* 与标记清楚一样，标记活动对象
* 然后将活动对象往一端移动，移动完成后，直接清理掉边界外的内存
* 最后进行释放和回收相应空间

##### 优点

* 解决了碎片化的问题

##### 缺点

* 不会立即回收对象

#### 复制算法 Scavenge

核心思想：将内存分为两个相等的部分，将存活对象在两个semispace空间之间进行复制。

* 将堆内存一分为二，每一部分空间称为semispace。
* 在这两个semispace空间中，只有一个处于使用中，另一个处于闲置状态。
* 处于使用状态的semispace空间称为From空间，处于闲置状态的空间称为To空间。
* 当我们分配对象时，先是在From空间中进行分配。
* 当开始进行垃圾回收时，会检查From空间中的存活对象，这些存活对象将被复制到To空间中，而非存活对象占用的空间将会被释放。
* 完成复制后，From空间和To空间的角色发生兑换。

##### 优点

* 没有内存碎片，只要移动堆顶指针，按顺序分配内存即可。

##### 缺点

* 是只能使用堆内存中的一半，牺牲空间换取时间

#### 分代回收

核心思想：将内存中的对象分为两部分，新生代和老生代，分别存储在不同的位置，应用不同的回收机制

* 新生代的对象为存活时间较短的对象，老生代的对象为存活时间较长或常驻内存的对象
* 根据某种规则，将新生代区域的对象部分放入老生代中
* 两个区域按照各自的规则进行各自回收

##### 优点

* 引用多种情况，分别处理不同状况下的回收

### V8 垃圾回收

V8是一款主流的JavaScript执行引擎，浏览器中采用V8来执行JavaScript代码。

V8设置了内存大小，32位：800M，64位：1.5G。

#### 垃圾回收策略

采用分代回收机制，

* 新生代区域(32M｜16M)存储存活时间较短的对象
* 老生代区域(1.4G | 700M)存储存活时间较长的对象，比如全局变量，闭包中的变量

#### 新生代区域回收

采用复制算法

* 使用复制算法进行创建对象和垃圾回收
* 新生代中对象的生命周期较短，使用复制算法，在时间效率上有着优异的表现
* 但在分代式垃圾回收前提下，From空间中的存活对象在复制到To空间之前需要进行检查。在一定条件下，需要将存活周期长的对象移动到老生代中，也就是完成对象晋升

#### 新生代区域晋升

将新生代区域内部的对象移动至老生代区域

* 判断对象是否经历过Scavenge，即经历过一次复制。对象从From空间中复制到To空间时，会检查它的内存地址来判断这个对象是否已经经历过一次Scavenge回收。如果已经经历过了，会将该对象从From空间复制到老生代空间中，如果没有，则复制到To空间中。
* To空间的内存占用比超过限制，当要从From空间复制一个对象到To空间时，如果To空间已经使用了超过25%，则这个对象直接晋升到老生代空间中。
* 设置25%这个限制值的原因是当这次Scavenge回收完成后，这个To空间将变成From空间，接下来的内存分配将在这个空间中进行。如果占比过高，会影响后续的内存分配。对象晋升后，将会在老生代空间中作为存活周期较长的对象来对待，接受新的回收算法处理。

#### 老生代区域回收

采用标记清楚，标记整理，增量标记 

* 首先使用标记清楚完成垃圾空间回收
* 当产生新生代区域晋升时，老生代如果空间不足，采用标记整理进行空间优化

####增量标记

增量标记算法进行效率优化

* 为了避免出现js应用逻辑与垃圾回收器看到的不一致的情况，垃圾回收的3种基本算法都需要将应用逻辑暂停下来，待执行完垃圾回收后再恢复执行应用逻辑，这种行为被称为“全停顿”（stop-the-world）。
* 在V8的分代式垃圾回收中，一次小垃圾回收只收集新生代，由于新生代默认配置得较小，且其中存活对象通常较少，所以即便它是全停顿的影响也不大。
* 但V8的老生代通常配置得较大，且存活对象较多，全堆垃圾回收（full垃圾回收）的标记、清理、整理等动作造成的停顿就会比较可怕，需要设法改善。
* 为了降低全堆垃圾回收带来的停顿时间，V8先从标记阶段入手，将原本要一口气停顿完成的动作改为增量标记（incremental marking），也就是拆分为许多小“步进”，每做完一“步进”就让js应用逻辑执行一小会，垃圾回收与应用逻辑交替执行直到标记阶段完成。
* V8后续还引入了延迟清理（lazy sweeping）与增量式整理（incremental compaction），让清理与整理动作也变成增量式的。同时还计划引入并行标记与并行清理，进一步利用多核性能降低每次停顿的时间。

