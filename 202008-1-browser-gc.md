# JavaScript垃圾回收机制

> 参考链接：https://github.com/zqjflash/nodejs-memory

javascript中声明变量都会开辟出新的内存地址储存变量内容，随着程序的运行，运用到的变量会越来越多，这个时候就需要对一些“垃圾”变量进行清理，对他们所占用的内存进行回收。以此保证程序的流畅运行。

javascript的内存管理是自动的，会在特定时机运用**GC算法**进行垃圾回收

当一个内存地址，不再被引用，或者没有能访问到的指针时，就被视为“垃圾”。简单点来说，就是这个变量对程序运行是无用的，或者是没有办法用的，这个时候，它就是一个“垃圾”，需要被回收。

### GC算法

GC是一种机制，内部包含一个垃圾回收器，它会按照某种规则，完成按照垃圾，释放空间，回收空间的等工作。这种规则就是GC算法

#### 引用计数

核心思想：对每个变量设置引用数，判断当前引用数是否为0

* 建立引用计数器
* 引用关系发生改变时修改引用数
* 引用数字为0时，立即清理垃圾

##### 优点

* 发现垃圾立即回收，减少申请内存时的耗时，减少程序暂停

##### 缺点

* 无法回收循环对象
* 时间开销大，维护引用计数器需要耗时

#### 标记清除 Mark-Sweep

核心思想：将垃圾回收分为标记和清除两个阶段

* 遍历所有的对像寻找活动对象进行标记
* 遍历所有的对象清楚没有标记的对象
* 回收相应空间

##### 优点

* 可以回收循环对象
* 不需要维护额外的计数器

##### 缺点

* 清除了没有标记的对象，释放了对应的内存，但是释放的内存并不连续，无法很好的被再次利用，导致内存碎片化
* 不会立即回收对象

#### 标记整理 Mark-Compact

核心思想：与标记清除一致，多了整理内存的操作

* 与标记清楚一样，标记活动对象
* 然后将活动对象往一端移动，移动完成后，直接清理掉边界外的内存
* 最后进行释放和回收相应空间

##### 优点

* 解决了碎片化的问题

##### 缺点

* 不会立即回收对象

#### 复制算法 Scavenge

核心思想：将内存分为两个相等的部分，将存活对象在两个semispace空间之间进行复制。

* 将堆内存一分为二，每一部分空间称为semispace。
* 在这两个semispace空间中，只有一个处于使用中，另一个处于闲置状态。
* 处于使用状态的semispace空间称为From空间，处于闲置状态的空间称为To空间。
* 当我们分配对象时，先是在From空间中进行分配。
* 当开始进行垃圾回收时，会检查From空间中的存活对象，这些存活对象将被复制到To空间中，而非存活对象占用的空间将会被释放。
* 完成复制后，From空间和To空间的角色发生兑换。

##### 优点

* 没有内存碎片，只要移动堆顶指针，按顺序分配内存即可。

##### 缺点

* 是只能使用堆内存中的一半，牺牲空间换取时间

#### 分代回收

核心思想：将内存中的对象分为两部分，新生代和老生代，分别存储在不同的位置，应用不同的回收机制

* 新生代的对象为存活时间较短的对象，老生代的对象为存活时间较长或常驻内存的对象
* 根据某种规则，将新生代区域的对象部分放入老生代中
* 两个区域按照各自的规则进行各自回收

##### 优点

* 引用多种情况，分别处理不同状况下的回收

### V8 垃圾回收

V8是一款主流的JavaScript执行引擎，浏览器中采用V8来执行JavaScript代码。

V8设置了内存大小，32位：800M，64位：1.5G。

#### 垃圾回收策略

采用分代回收机制，

* 新生代区域(32M｜16M)存储存活时间较短的对象
* 老生代区域(1.4G | 700M)存储存活时间较长的对象，比如全局变量，闭包中的变量

#### 新生代区域回收

采用复制算法

* 使用复制算法进行创建对象和垃圾回收
* 新生代中对象的生命周期较短，使用复制算法，在时间效率上有着优异的表现
* 但在分代式垃圾回收前提下，From空间中的存活对象在复制到To空间之前需要进行检查。在一定条件下，需要将存活周期长的对象移动到老生代中，也就是完成对象晋升

#### 新生代区域晋升

将新生代区域内部的对象移动至老生代区域

* 判断对象是否经历过Scavenge，即经历过一次复制。对象从From空间中复制到To空间时，会检查它的内存地址来判断这个对象是否已经经历过一次Scavenge回收。如果已经经历过了，会将该对象从From空间复制到老生代空间中，如果没有，则复制到To空间中。
* To空间的内存占用比超过限制，当要从From空间复制一个对象到To空间时，如果To空间已经使用了超过25%，则这个对象直接晋升到老生代空间中。
* 设置25%这个限制值的原因是当这次Scavenge回收完成后，这个To空间将变成From空间，接下来的内存分配将在这个空间中进行。如果占比过高，会影响后续的内存分配。对象晋升后，将会在老生代空间中作为存活周期较长的对象来对待，接受新的回收算法处理。

#### 老生代区域回收

采用标记清楚，标记整理，增量标记 

* 首先使用标记清楚完成垃圾空间回收
* 当产生新生代区域晋升时，老生代如果空间不足，采用标记整理进行空间优化

#### 增量标记

增量标记算法进行效率优化

* 为了避免出现js应用逻辑与垃圾回收器看到的不一致的情况，垃圾回收的3种基本算法都需要将应用逻辑暂停下来，待执行完垃圾回收后再恢复执行应用逻辑，这种行为被称为“全停顿”（stop-the-world）。
* 在V8的分代式垃圾回收中，一次小垃圾回收只收集新生代，由于新生代默认配置得较小，且其中存活对象通常较少，所以即便它是全停顿的影响也不大。
* 但V8的老生代通常配置得较大，且存活对象较多，全堆垃圾回收（full垃圾回收）的标记、清理、整理等动作造成的停顿就会比较可怕，需要设法改善。
* 为了降低全堆垃圾回收带来的停顿时间，V8先从标记阶段入手，将原本要一口气停顿完成的动作改为增量标记（incremental marking），也就是拆分为许多小“步进”，每做完一“步进”就让js应用逻辑执行一小会，垃圾回收与应用逻辑交替执行直到标记阶段完成。
* V8后续还引入了延迟清理（lazy sweeping）与增量式整理（incremental compaction），让清理与整理动作也变成增量式的。同时还计划引入并行标记与并行清理，进一步利用多核性能降低每次停顿的时间。

### 高效使用内存

#### 主动释放变量

js在执行代码时，遇到变量，会去查找变量定义在什么地方，现在当前作用域内查找，在想上层作用域查找，直到全局作用域，如果还没有就报错

函数被调用的时候，会创建对应的作用域，在执行结束后，作用域会被销毁，局部变量也会被随之销毁，销毁之后，这块占用的内存会在下次垃圾回收时被释放

全局变量只会在进程提出之后才能释放，此时，将导致引用的对象常驻内存(老生代区域)之中。想要释放这部分内存，就只能通过重新赋值，或者`delete`删除引用关系

在其他作用域中也可以通过这样的方式主动释放内存，一般建议使用重新赋值，`delete`会干扰V8优化

#### 慎用闭包

闭包是利用高阶函数的特性来实现的，高阶函数中，函数可以作为参数或者返回值。这样就可以声明一个局部变量，这个变量外界无法直接访问到，只可以通过中间函数获得，例如：

```javascript
var foo = function() {
  var bar = function() {
    var local = "局部变量";
    return function() {
      return local;
    };
  };
  var baz = bar();
  console.log(baz());
};
```

这里的local就只能被baz这个中间函数访问到，这就是一个闭包。在这个闭包中，bar()函数执行完成后，局部变量local将会随着作用域的销毁而被回收。但是返回了一个匿名函数，且这个函数中具备了访问local的条件。虽然在后续的执行中，在外部作用域中还是无法直接访问local，但是若要访问它，可以通过中间函数来过渡。

一旦有变量引用了这个中间函数，这个中间函数将不会被释放，同时作用域中产生内存占用也不会被释放，除非不再有引用，才会逐步释放。

#### 慎用内存当作缓存

js开发中喜欢用对象的键值对来缓存东西，例如：

```javascript
var cache = {};
var get = function(key) {
  if (cache[key]) {
    return cache[key];
  } else {
    // get from otherwise
  }
};
var set = function (key, value) {
  cache[key] = value;
};
```

但这并不严格意义上的缓存，因为，它没有完善的过期策略和大小限制，这会导致内存无限制增大，而且不会被释放，在大量执行后，会被占用大量内存，出现内存泄漏。

#### 总结

**在正常js执行中，无法立即回收的内存有闭包和全局变量引用这两种情况。由于V8的内存限制，要十分小心此类变量是否无限制地增加，因为它会导致老生代中的对象增多，导致内存泄漏。而我们有时也会人为的“创造”一些不会清除的引用缓存，这个时候就要通过合适的策略对这个缓存进行限制，否则也会造成内存无限制增大，内存泄漏**

