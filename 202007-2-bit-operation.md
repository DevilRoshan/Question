# 位运算

> 参考链接：
>
> https://www.zhihu.com/question/38206659/answer/736472332
>
> https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators

计算机中的数在内存中都是以二进制形式进行存储的，用位运算就是直接对整数在内存中的二进制位进行操作，因此其执行效率非常高。

记得以前大牛的一种说法

> 位运算针对的是整数，所以对 JavaScript 完全无用，因为 JavaScript 内部，所有数字都保存为双精度浮点数。如果使用它们的话，JavaScript 不得不将运算数先转为整数，然后再进行运算，这样就降低了速度。而且位运算运算符与逻辑运算符有时容易搞混

但是，对于某些场景，位运算还是非常重要的，不仅能提升性能，简化运算，而且能够避免很多坑

## 按位操作符

**按位操作符（Bitwise operators）** 将其操作数（operands）当作32位的比特序列（二进制，由0和1组成），而不是十进制、十六进制或八进制。例如，十进制数9，用二进制表示则为1001。按位操作符操作数字的二进制形式，但是返回值依然是标准的JavaScript数值。

### 有符号32位整数

将一个数转化为二进制形式，并且补全32位，即`9 => 0000 0000 0000 0000 0000 0000 0000 0101`即`9 = 2^3 + 2^1`此处的`1`和`3`就代表二进制书的从右起的第`1`位和第`3`位

javascript将所有按位操作符的操作数转化为补码形式的有符号32位整数。

补码形式是指一个数的负对应值（negative counterpart）（如 5和-5）为数值的所有比特位反转后，再加1。即`-a = ~a + 1`。例如

```
 314(base10) = 0000 0000 0000 0000 0000 0001 0011 1010(base2)
 							 ---- ---- ---- ---- ---- ---- ---- ----
~314(base10) = 1111 1111 1111 1111 1111 1110 1100 0101(base2) // 反码
							 ---- ---- ---- ---- ---- ---- ---- ----
-314(base10) = 1111 1111 1111 1111 1111 1110 1100 0110(base2) // 反码+1，表示负数
```

这样如果是正数，则左起第一位为0，如果是负数，左起第一位为1。左起第一位为符号位

所以有以下结果

```
0000 0000 0000 0000 0000 0000 0000 0000(base2) === 0(base10)
1111 1111 1111 1111 1111 1111 1111 1111(base2) === -1(base10)
1000 0000 0000 0000 0000 0000 0000 0000(base2) === -2147483648(base10) //32位最小整数
0111 1111 1111 1111 1111 1111 1111 1111(base2) === 2147483647(base10) //32位最大整数
```

按位操作符在进行按位操作之前会先将操作数转换成32位整数，用比特序列（0和1组成）表示。超过32位的数字会被丢弃。比如：

```
转换前: 1110 0110 1111 1010 0000 0000 0000 0110 0000 0000 0001
转换后:                1010 0000 0000 0000 0110 0000 0000 0001
```

因为最左边的0是无效的，有时我们会将其进行简写

```
 314(base10) = 0000 0000 0000 0000 0000 0001 0011 1010(base2)
 // 简写为
 314(base10) = 100111010(base2)
```

**如果是js中书写二进制数位**，在二进制数字前添加`0b`前缀

```javascript
314 = 0b100111010
```

### 按位逻辑操作符

* 将操作数转化为有符号32位整数
* 从右到左按比特位进行匹配，按位对应
* 位运算操作应用到每对比特位，然后返回新的结果

#### 按位与`&`

对每对比特位执行**与（AND）操作**。只有 a 和 b 都是 1 时，a AND b 才是 1。**与操作**的真值表：

| a    | b    | a AND b |
| ---- | ---- | ------- |
| 0    | 0    | 0       |
| 0    | 1    | 0       |
| 1    | 0    | 0       |
| 1    | 1    | 1       |

**示例如下**

```
 		 9 (base 10) = 1001 (base 2)
    14 (base 10) = 1110 (base 2)
                   ----
14 & 9 (base 10) = 1000 (base 2) = 8 (base 10)
```

将任一数值 x 与 0 执行按位与操作，其结果都为 0。将任一数值 x 与 -1 执行按位与操作，其结果都为 x。

#### 按位或`|`

对每对比特位执行**或（OR）操作**。如果 a 或 b 为 1，则 `a` OR `b` 结果为 1。**或操作**的真值表：

| a    | b    | a OR b |
| ---- | ---- | ------ |
| 0    | 0    | 0      |
| 0    | 1    | 1      |
| 1    | 0    | 1      |
| 1    | 1    | 1      |

**示例如下**

```
 		 9 (base 10) = 1001 (base 2)
    14 (base 10) = 1110 (base 2)
                   ----
14 | 9 (base 10) = 1111 (base 2) = 15 (base 10)
```

将任一数值 x 与 0 进行按位或操作，其结果都是 x。将任一数值 x 与 -1 进行按位或操作，其结果都为 -1。

#### 按位异或`^`

对每对比特位执行**异或（XOR）操作**。当 a 和 b 不相同时，`a` XOR `b` 的结果为 1。**异或操作**真值表：

| a    | b    | a XOR b |
| ---- | ---- | ------- |
| 0    | 0    | 0       |
| 0    | 1    | 1       |
| 1    | 0    | 1       |
| 1    | 1    | 0       |

**示例如下**

```
 		 9 (base 10) = 1001 (base 2)
    14 (base 10) = 1110 (base 2)
                   ----
14 | 9 (base 10) = 0111 (base 2) = 7 (base 10)
```

将任一数值 x 与 0 进行异或操作，其结果为 x。将任一数值 x 与 -1 进行异或操作，其结果为 ~x。

#### 按位非`~`

对每一个比特位执行**非（NOT）操作**。NOT `a` 结果为 a 的反转（即反码）。**非操作**的真值表：

| a    | NOT a |
| ---- | ----- |
| 0    | 1     |
| 1    | 0     |

**示例如下**

```
 9 (base 10) = 1001 (base 2)
               ----
~9 (base 10) = 0110 (base 2) = -10 (base 10)
```

对任一数值 x 进行按位非操作的结果为 -(x + 1)。例如，~5 结果为 -6。

### 按位移动操作符

按位移动操作符有两个操作数：第一个是要被移动的数字，而第二个是要移动的长度。移动的方向根据操作符的不同而不同。

* 将操作数转化为有符号32位整数
* 进行相关移动操作

#### 左移`<<`

该操作符会将第一个操作数向左移动指定的位数。向左被移出的位被丢弃，右侧用 0 补充。

```
     9 (base 10) = 0000 1001 (base 2)
              		 ---- ----
9 << 2 (base 10) = 0010 0100 (base 2) = 36 (base 10)
```

数学公式为：`res = x * 2 ^ y`

#### 有符号右移`>>`

该操作符会将第一个操作数向右移动指定的位数。向右被移出的位被丢弃，拷贝最左侧的位以填充左侧。由于新的最左侧的位总是和以前相同，符号位没有被改变。所以被称作“符号传播”。

```
// 正数
		 9 (base 10) = 0000 1001 (base 2)
              		 ---- ----
9 >> 2 (base 10) = 0000 0010 (base 2) = 2 (base 10)

// 负数，这里省略了前面的1，实际不应该省略
		  9 (base 10) = 0000 0000 0000 0000 0000 0000 1001 (base 2) // 正数
              		  ---- ---- ---- ---- ---- ---- ----
     ~9 (base 10) = 1111 1111 1111 1111 1111 1111 0110 (base 2) // 反码
              		  ---- ---- ---- ---- ---- ---- ----
     -9 (base 10) = 1111 1111 1111 1111 1111 1111 0111 (base 2) // 负数 = 反码 + 1
              		  ---- ---- ---- ---- ---- ---- ----
-9 >> 2 (base 10) = 1111 1111 1111 1111 1111 1111 1101 (base 2) = -3 (base 10)
```

#### 无符号右移`>>>`

该操作符会将第一个操作数向右移动指定的位数。向右被移出的位被丢弃，左侧用0填充。因为符号位变成了 0，所以结果总是非负的。（译注：即便右移 0 个比特，结果也是非负的。）

对于非负数，有符号右移和无符号右移总是返回相同的结果。例如 `9 >>> 2` 和 `9 >> 2` 一样返回 2：

```
// 正数，与右移一致
		  9 (base 10) = 0000 1001 (base 2)
              	 	  ---- ----
9 >>> 2 (base 10) = 0000 0010 (base 2) = 2 (base 10)

// 负数
		  9 (base 10) = 0000 0000 0000 0000 0000 0000 1001 (base 2) // 正数
              		  ---- ---- ---- ---- ---- ---- ----
     ~9 (base 10) = 1111 1111 1111 1111 1111 1111 0110 (base 2) // 反码
              		  ---- ---- ---- ---- ---- ---- ----
     -9 (base 10) = 1111 1111 1111 1111 1111 1111 0111 (base 2) // 负数 = 反码 + 1
              		  ---- ---- ---- ---- ---- ---- ----
-9 >> 2 (base 10) = 0011 1111 1111 1111 1111 1111 1101 (base 2) = 1073741821 (base 10)
```

## 运算符的奇技淫巧

### 标志位与掩码

位运算经常被用来创建、处理以及读取标志位序列——一种类似二进制的变量。虽然可以使用变量代替标志位序列，但是这样可以节省内存（1/32）。

例如：

比如linux系统中关于文件的读，写，执行， 3个权限，就是用3个状态为标识的

* r，表示为read，掩码为`4 (base 10) = 0100 (base 2)`
* w，表示为write，掩码为`2 (base 10) = 0010 (base 2)`
* x，表示为execute，掩码为`1 (base 10) = 0001 (base 2)`

那么一个文件如果有读写执行权限，那么他的权限标识就是`7 (base 10) = 0111 (base 2)`。

如果要修改某个文件的权限，只需要修改它对应的表示二进制序列就可以了，可以对其进行逻辑运算，会更加简单，而不是数字的加减操作，比如添加权限就进行`&`运算，去除就可以`& 和 ~`运算

### 交换两数

```
b = a ^ b;
a = a ^ b;
b = a ^ b;
```

### 小技巧

#### 判断奇偶

```
console.log(7 & 1);   // 1
console.log(8 & 1);   // 0
```

#### 取整(非负数)

```
console.log(~~11.71)     // 11
console.log(11.71 >> 0)  // 11
console.log(11.71 << 0)  // 11
console.log(11.71 | 0)   // 11
console.log(11.71 >>> 0) // 11
```

#### 交换符号

```
~a + 1
```



